#' - 64 bits float per sample
#' Parameters
#' ----------
#' file : str
#' Path to the file containing the sniff data
#' Returns
#' -------
#' sniff : np.array
#' Array containing the sniff data
# Load sniff data which is stored as 64 bits float
sniff <- readBin(file, what = "double", n = 1e6, size = 8, endian = "little")
# Extract the sniff data which is stored every 4 samples
sniff <- sniff[seq(1, length(sniff), by = 4)]
return(sniff)
}
resample_sniff <- function(sniff, original_rate = 30000, target_rate = 1000) {
#' Resample a sniff signal from an original rate to a target rate.
#' This function applies a decimation process to a sniff signal, which is useful in
#' situations where lower sampling rates are sufficient or desired for analysis. The
#' decimation is performed using a Finite Impulse Response (FIR) filter with a Hamming
#' window to reduce aliasing effects.
#' Parameters:
#' sniff (np.array): The sniff signal to be resampled, represented as a NumPy array.
#' original_rate (int, optional): The original sampling rate of the signal in Hz. Defaults to 30000 Hz.
#' target_rate (int, optional): The desired sampling rate of the signal in Hz. Defaults to 1000 Hz.
#' Returns:
#' np.array: The resampled sniff signal.
# calculating resample factor
resample_factor <- original_rate %/% target_rate
# calculating new length of resampled signal
if (length(sniff) %% resample_factor != 0) {
sniff <- sniff[1:(length(sniff) - (length(sniff) %% resample_factor))]
}
# applying decimation to the signal
resampled_sniff <- signal::decimate(sniff, resample_factor)
return(resampled_sniff)
}
find_inhales_2 <- function(data, window_length = 51, polyorder = 5,
min_peak_prominance = 0.3, distance = 50, show = FALSE,
signal_type = 'sniff', save_figs = FALSE, name = NULL, f = 1000) {
inhale_times <- c()
# smoothing the signal
data_smooth <- signal::sgolayfilt(data, p = polyorder, n = window_length)
# defining windows to work in
windows <- seq(0, length(data_smooth), by = (5 * f))
# looping through windows
for (scan in 2:length(windows)) {
# defining time stamp
time_stamp <- windows[scan - 1]:windows[scan]
# zscoring the signal
zsniff <- scale(data_smooth[time_stamp])
# finding peaks
peaks <- findpeaks(zsniff, minpeakprominence = min_peak_prominance, minpeakdistance = distance)
if (!is.null(peaks)) {
inhale_times <- c(inhale_times, peaks[,2] + time_stamp[1])
}
}
# plotting
if (show) {
plot(inhale_times, data_smooth[inhale_times], 'x', main = 'Peaks')
if (signal_type == 'sniff') {
lines(data, col = 'blue', main = 'Original Sniff Signal')
lines(data_smooth, col = 'red', main = 'Smoothed Sniff Signal')
title('Sniff Signal and Identified Peaks')
} else if (signal_type == 'lfp') {
lines(data, col = 'blue', main = 'Original LFP Signal')
lines(data_smooth, col = 'red', main = 'Smoothed LFP Signal')
title('LFP Signal and Identified Peaks')
}
xlabel('Sample')
ylabel('Signal Amplitude')
legend('topright', legend = c('Peaks', 'Original Signal', 'Smoothed Signal'), col = c('black', 'blue', 'red'), lty = 1:2, cex = 0.8)
}
return(inhale_times)
}
data_path <- "D:/newmove/2213/100-0/18/NiDAQ_sniff.dat"
# extracting and resampling signal
raw_sniff <- load_sniff_FMON(data_path)
sniff <- resample_sniff(load_sniff_FMON(data_path))
start <- 0
end <- 10000
# Plot resampled sniff signal
plot(sniff[start:end], type = 'l', main = 'Resampled sniff signal', xlab = 'Samples', ylab = 'Voltage')
# smooth signal
sniff_smooth <- signal::sgolayfilt(sniff, p = 3, n = 51)
sos <- signal::butter(10, c(1/500, 20/500), type = 'pass')
sniff_smooth <- signal::filtfilt(sos, sniff_smooth)
peaks <- find_inhales_2(sniff, show = FALSE, signal_type = 'sniff', save_figs = FALSE, name = NULL, f = 1000)
peaks <- unlist(peaks)
peaks_use <- which((peaks > start) & (peaks < end))
# Plot resampled sniff signal with peaks
plot(sniff_smooth[start:end], type = 'l', main = 'Resampled Sniff Signal with Peaks', xlab = 'Samples', ylab = 'Voltage')
points(peaks[peaks_use] - start, sniff_smooth[peaks[peaks_use]], col = 'red', pch = 3)
# computing differences between inhalation times
diffs <- diff(peaks)
# correcting for lost final inhalation
times <- peaks[-length(peaks)] / 1000
# computing frequencies
frequencies <- 1000 / diffs
# plotting
ggplot(data.frame(times = times, frequencies = frequencies), aes(x = times, y = frequencies)) +
geom_point(color = 'dodgerblue') +
theme_minimal() +
labs(title = 'Sniff Frequency Over Time', x = 'Time (s)', y = 'Frequency (Hz)')
install.packages("pracma")
library(signal)
library(dplyr)
library(ggplot2)
library(zoo)
library(purrr)
library(readr)
library(pracma)
load_sniff_FMON <- function(file) {
#' Loads sniff data from FMON rig.
#' This function loads the sniff data from the FMON rig.
#' The data is stored in a binary file with the following format:
#' - 4 bytes per sample
#' - 64 bits float per sample
#' Parameters
#' ----------
#' file : str
#' Path to the file containing the sniff data
#' Returns
#' -------
#' sniff : np.array
#' Array containing the sniff data
# Load sniff data which is stored as 64 bits float
sniff <- readBin(file, what = "double", n = 1e6, size = 8, endian = "little")
# Extract the sniff data which is stored every 4 samples
sniff <- sniff[seq(1, length(sniff), by = 4)]
return(sniff)
}
resample_sniff <- function(sniff, original_rate = 30000, target_rate = 1000) {
#' Resample a sniff signal from an original rate to a target rate.
#' This function applies a decimation process to a sniff signal, which is useful in
#' situations where lower sampling rates are sufficient or desired for analysis. The
#' decimation is performed using a Finite Impulse Response (FIR) filter with a Hamming
#' window to reduce aliasing effects.
#' Parameters:
#' sniff (np.array): The sniff signal to be resampled, represented as a NumPy array.
#' original_rate (int, optional): The original sampling rate of the signal in Hz. Defaults to 30000 Hz.
#' target_rate (int, optional): The desired sampling rate of the signal in Hz. Defaults to 1000 Hz.
#' Returns:
#' np.array: The resampled sniff signal.
# calculating resample factor
resample_factor <- original_rate %/% target_rate
# calculating new length of resampled signal
if (length(sniff) %% resample_factor != 0) {
sniff <- sniff[1:(length(sniff) - (length(sniff) %% resample_factor))]
}
# applying decimation to the signal
resampled_sniff <- signal::decimate(sniff, resample_factor)
return(resampled_sniff)
}
find_inhales_2 <- function(data, window_length = 51, polyorder = 5,
min_peak_prominance = 0.3, distance = 50, show = FALSE,
signal_type = 'sniff', save_figs = FALSE, name = NULL, f = 1000) {
inhale_times <- c()
# smoothing the signal
data_smooth <- signal::sgolayfilt(data, p = polyorder, n = window_length)
# defining windows to work in
windows <- seq(0, length(data_smooth), by = (5 * f))
# looping through windows
for (scan in 2:length(windows)) {
# defining time stamp
time_stamp <- windows[scan - 1]:windows[scan]
# zscoring the signal
zsniff <- scale(data_smooth[time_stamp])
# finding peaks
peaks <- pracma::findpeaks(zsniff, minpeakprominence = min_peak_prominance, minpeakdistance = distance)
if (!is.null(peaks)) {
inhale_times <- c(inhale_times, peaks[,2] + time_stamp[1])
}
}
# plotting
if (show) {
plot(inhale_times, data_smooth[inhale_times], 'x', main = 'Peaks')
if (signal_type == 'sniff') {
lines(data, col = 'blue', main = 'Original Sniff Signal')
lines(data_smooth, col = 'red', main = 'Smoothed Sniff Signal')
title('Sniff Signal and Identified Peaks')
} else if (signal_type == 'lfp') {
lines(data, col = 'blue', main = 'Original LFP Signal')
lines(data_smooth, col = 'red', main = 'Smoothed LFP Signal')
title('LFP Signal and Identified Peaks')
}
xlabel('Sample')
ylabel('Signal Amplitude')
legend('topright', legend = c('Peaks', 'Original Signal', 'Smoothed Signal'), col = c('black', 'blue', 'red'), lty = 1:2, cex = 0.8)
}
return(inhale_times)
}
data_path <- "D:/newmove/2213/100-0/18/NiDAQ_sniff.dat"
# extracting and resampling signal
raw_sniff <- load_sniff_FMON(data_path)
sniff <- resample_sniff(load_sniff_FMON(data_path))
start <- 0
end <- 10000
# Plot resampled sniff signal
plot(sniff[start:end], type = 'l', main = 'Resampled sniff signal', xlab = 'Samples', ylab = 'Voltage')
# smooth signal
sniff_smooth <- signal::sgolayfilt(sniff, p = 3, n = 51)
sos <- signal::butter(10, c(1/500, 20/500), type = 'pass')
sniff_smooth <- signal::filtfilt(sos, sniff_smooth)
peaks <- find_inhales_2(sniff, show = FALSE, signal_type = 'sniff', save_figs = FALSE, name = NULL, f = 1000)
peaks <- unlist(peaks)
peaks_use <- which((peaks > start) & (peaks < end))
# Plot resampled sniff signal with peaks
plot(sniff_smooth[start:end], type = 'l', main = 'Resampled Sniff Signal with Peaks', xlab = 'Samples', ylab = 'Voltage')
points(peaks[peaks_use] - start, sniff_smooth[peaks[peaks_use]], col = 'red', pch = 3)
# computing differences between inhalation times
diffs <- diff(peaks)
# correcting for lost final inhalation
times <- peaks[-length(peaks)] / 1000
# computing frequencies
frequencies <- 1000 / diffs
# plotting
ggplot(data.frame(times = times, frequencies = frequencies), aes(x = times, y = frequencies)) +
geom_point(color = 'dodgerblue') +
theme_minimal() +
labs(title = 'Sniff Frequency Over Time', x = 'Time (s)', y = 'Frequency (Hz)')
find_inhales_2 <- function(data, window_length = 51,
polyorder = 5, min_peak_prominance = 0.3,
distance = 50, show = FALSE, signal_type = 'sniff',
save_figs = FALSE, name = NULL, f = 1000) {
inhale_times <- c()
# smoothing the signal
data_smooth <- signal::sgolayfilt(data, p = polyorder, n = window_length)
# defining windows to work in
windows <- seq(0, length(data_smooth), by = (5 * f))
# looping through windows
for (scan in 2:length(windows)) {
# defining time stamp
time_stamp <- windows[scan - 1]:windows[scan]
# zscoring the signal
zsniff <- scale(data_smooth[time_stamp])
# finding peaks
peaks <- pracma::findpeaks(zsniff, minpeakheight = min_peak_prominance, minpeakdistance = distance)
if (!is.null(peaks)) {
inhale_times <- c(inhale_times, peaks[,2] + time_stamp[1])
}
}
# plotting
if (show) {
plot(inhale_times, data_smooth[inhale_times], 'x', main = 'Peaks')
if (signal_type == 'sniff') {
lines(data, col = 'blue', main = 'Original Sniff Signal')
lines(data_smooth, col = 'red', main = 'Smoothed Sniff Signal')
title('Sniff Signal and Identified Peaks')
} else if (signal_type == 'lfp') {
lines(data, col = 'blue', main = 'Original LFP Signal')
lines(data_smooth, col = 'red', main = 'Smoothed LFP Signal')
title('LFP Signal and Identified Peaks')
}
xlabel('Sample')
ylabel('Signal Amplitude')
legend('topright', legend = c('Peaks', 'Original Signal', 'Smoothed Signal'), col = c('black', 'blue', 'red'), lty = 1:2, cex = 0.8)
}
return(inhale_times)
}
data_path <- "D:/newmove/2213/100-0/18/NiDAQ_sniff.dat"
# extracting and resampling signal
raw_sniff <- load_sniff_FMON(data_path)
sniff <- resample_sniff(load_sniff_FMON(data_path))
start <- 0
end <- 10000
# Plot resampled sniff signal
plot(sniff[start:end], type = 'l', main = 'Resampled sniff signal', xlab = 'Samples', ylab = 'Voltage')
# smooth signal
sniff_smooth <- signal::sgolayfilt(sniff, p = 3, n = 51)
sos <- signal::butter(10, c(1/500, 20/500), type = 'pass')
sniff_smooth <- signal::filtfilt(sos, sniff_smooth)
peaks <- find_inhales_2(sniff, show = FALSE, signal_type = 'sniff', save_figs = FALSE, name = NULL, f = 1000)
peaks <- unlist(peaks)
peaks_use <- which((peaks > start) & (peaks < end))
# Plot resampled sniff signal with peaks
plot(sniff_smooth[start:end], type = 'l', main = 'Resampled Sniff Signal with Peaks', xlab = 'Samples', ylab = 'Voltage')
points(peaks[peaks_use] - start, sniff_smooth[peaks[peaks_use]], col = 'red', pch = 3)
# computing differences between inhalation times
diffs <- diff(peaks)
# correcting for lost final inhalation
times <- peaks[-length(peaks)] / 1000
# computing frequencies
frequencies <- 1000 / diffs
# plotting
ggplot(data.frame(times = times, frequencies = frequencies), aes(x = times, y = frequencies)) +
geom_point(color = 'dodgerblue') +
theme_minimal() +
labs(title = 'Sniff Frequency Over Time', x = 'Time (s)', y = 'Frequency (Hz)')
# Chunk 1: setup
knitr::opts_chunk$set(echo = TRUE)
options(warn = -1)
library(ggplot2)
library(janitor)
library(dplyr)
library(stringr)
library(RColorBrewer)
library(scales)
library(ggrepel)
library(tidyverse)
# Chunk 2
# set working directory
setwd("C:/Users/Amanda Welch/Documents/GitHub/SOAK-Census")
# Chunk 3: data import
# import data
data <- read.csv("C:/Users/Amanda Welch/Desktop/SOAK 2023/census_data.csv")
# convert column names to lower case
data <- clean_names(data)
#remove 1st 2 rows with unnecessary info
data <- data[-(1:2),]
# Chunk 4: import 2024 data
data_2024 <- read.csv("C:/Users/Amanda Welch/Desktop/SOAK 2024/SOAK 2024_RawData.csv")
# Chunk 5: clean 2024 data
data_2024 <- clean_names(data_2024)
data_2024 <- data_2024[-(1:2),]
data_2024 <- data_2024[, !names(data_2024) %in%
c("start_date","end_date","status","ip_address","progress","duration_in_seconds",
"finished","recorded_date","response_id","recipient_last_name",
"recipient_first_name", "recipient_email","external_reference","location_latitude",
"location_longitude","distribution_channel","user_language","q_recaptcha_score")]
# Chunk 6: columns 2024
# rename columns for 2024
data_2024 <- data_2024 %>%
dplyr::rename(
attend = q1,
age = q2,
race = q3,
born = q4,
language = q5,
gender = q6,
orientation = q7,
relationship = q8,
religion = q9,
politics = q10,
edu = q11,
income = q12,
zip_code = q13,
arrive = q14,
rv = q15,
ticket = q16,
move = q17,
participate = q18,
sustain = q19,
townhall = q22,
bm = q23,
info = q24,
ada = q25,
military = q26,
kids = q27,
teens = q28,
time_arrival = q29
)
# Chunk 7: data cleaning 2023
# drop irrelevant columns generated by data entry
data <- data[, !names(data) %in%
c("start_date","end_date","status","ip_address","progress","duration_in_seconds",
"finished","recorded_date","response_id","recipient_last_name",
"recipient_first_name", "recipient_email","external_reference","location_latitude",
"location_longitude","distribution_channel","user_language","q_recaptcha_score")]
# rename columns
data <- data %>%
dplyr::rename(
attend = q1,
age = q2,
race = q3,
born = q4,
language = q5,
gender = q6,
orientation = q7,
relationship = q8,
religion = q9,
politics = q10,
edu = q11,
income = q12,
zip_code = q13,
arrive = q14,
rv = q15,
ticket = q16,
move = q17,
participate = q18,
sustain = q19,
kids = q20,
teens = q21,
townhall = q22,
bm = q23,
info = q24
)
# re-writing this entry - entered with "it's my 1st year" as well which can't be true if they also attended 3 years prior
data$attend[328] <- "2022,2019,2018"
# Chunk 8: attendance 2023
# rows (sometimes) store several year
# pull them out and separate years so they can be counted individually
attend_list <- strsplit(data$attend, ",")
attend_unlist <- unlist(attend_list)
occurrences <- table(attend_unlist)
occurrences_df <- as.data.frame(occurrences)
# get attendance count
# counting using commas - 0 commas per row means only have attended once, 1 comma = twice, etc.
# exclude virgins - will be its own count
attend_count <- str_count(data$attend[data$attend != "It's my first year!" &
data$attend != "Omitted"], ",")
virgins <- sum(data$attend == "It's my first year!")
count_0 <- sum(attend_count == 0)
count_1_2 <- sum(attend_count %in% c(1, 2))
count_3_6 <- sum(attend_count %in% c(3, 4, 5, 6))
count_7_or_more <- sum(attend_count >= 7)
# create a new data frame
attend_count_df <- data.frame(attendance = c("0","1", "2-3", "4-7", "8 or more"),
count = c(virgins, count_0, count_1_2, count_3_6, count_7_or_more))
attend_count_df$percent <- attend_count_df$count / sum(attend_count_df$count) * 100
attend_count_df$percent_round <- round(attend_count_df$percent, digits = 1)
View(data_2024)
View(data_2024)
#replace blanks with Omitted
data_2024[data_2024 == ""] <- "Omitted"
# rows (sometimes) store several year
# pull them out and separate years so they can be counted individually
attend_list_24 <- strsplit(data_2024$attend, ",")
attend_unlist_24 <- unlist(attend_list_24)
occurrences_24 <- table(attend_unlist_24)
occurrences_df_24 <- as.data.frame(occurrences_24)
# get attendance count
# counting using commas - 0 commas per row means only have attended once, 1 comma = twice, etc.
# exclude virgins - will be its own count
attend_count_24 <- str_count(data_2024$attend[data_2024$attend != "It's my first year!" &
data_2024$attend != "Omitted"], ",")
virgins_24 <- sum(data_2024$attend == "It's my first year!")
count_0_ <- sum(attend_count_24 == 0)
count_1_2_ <- sum(attend_count_24 %in% c(1, 2))
count_3_6_ <- sum(attend_count_24 %in% c(3, 4, 5, 6))
count_7_or_more_ <- sum(attend_count_24 >= 7)
# create a new data frame
attend_count_df_24 <- data.frame(attendance_24 = c("0","1", "2-3", "4-7", "8 or more"),
count_24 = c(virgins_24, count_0_, count_1_2_, count_3_6_, count_7_or_more_))
attend_count_df_24$percent_24 <- attend_count_df_24$count_24 / sum(attend_count_df_24$count_24) * 100
attend_count_df_24$percent_round_24 <- round(attend_count_df_24$percent, digits = 1)
attend_count_df <- cbind(attend_count_df, attend_count_df_24)
attend_count_df <- subset(attend_count_df, select = -attendance_24)
rm(attend_count_df_24)
# plot which years were reported attended
occurrences_df_24 %>%
ggplot(aes(x = attend_unlist_24,
y = Freq)) +
geom_bar(stat = "identity",
color = "black",
fill = "turquoise") +
labs(x = "Year attended",
y = "Number of participants",
title = "\nHow many participants were at which years") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# plot how many years attended
attend_count_df %>%
ggplot(aes(x = attendance, y = count_24, fill = count_24)) +
geom_bar(stat = "identity", color = "black", alpha = 0.8) +
labs(x = "Number of trips to SOAK",
y = "Number of participants",
title = "\n\n\nHow many times participants have previously attended SOAK",
caption = "Plot excludes omitted responses") +
geom_text(aes(label = count_24),
position = position_stack(vjust = 0.5),
size = 3.5, color = "black") +
guides(fill = FALSE) + #remove legend
theme_minimal()
# create variable of participants used instead of hard coding value in chart
participants <- sum(attend_count_df$count_24)
# maths for pie chart
pie_labels <- attend_count_df %>%
mutate(csum = rev(cumsum(rev(percent_round_24))),
pos = percent_round_24/2 + lead(csum, 1),
pos = if_else(is.na(pos), percent_round_24/2, pos))
# the plot
attend_count_df %>%
ggplot(aes(x = "", y = percent_round_24, fill = fct_inorder(attendance))) +
geom_col(width = 1, color = 1) +
coord_polar(theta = "y") +
scale_fill_brewer(palette = "Pastel2") +
geom_label_repel(data = pie_labels,
aes(y = pos, label = paste0(percent_round_24, "%")),
size = 4.5, nudge_x = 1, show.legend = FALSE) +
guides(fill = guide_legend(title = "Previous years attended")) +
ggtitle("\n\n\nAttendance history") +
labs(caption = paste(participants, "participants, excluding omitted responses \n")) +
theme_void()
# Reshape the data into long format
attend_long <- attend_count_df %>%
pivot_longer(cols = c("percent", "percent_24"),
names_to = "year",
values_to = "percent") %>%
mutate(year = recode(year, "percent" = "2023", "percent_24" = "2024"))
# Create spaghetti plot
attend_long %>%
ggplot(aes(x = year, y = percent, group = attendance, color = attendance)) +
geom_line(size = 1) +
geom_point(size = 3) +  # Optional, to emphasize points
labs(title = "Attendance change over time",
x = "Year",
y = "Percentage",
color = "How many times \nattended before 2024") +
theme_minimal()
# table showing stats instead of chart
subset_attend <- attend_count_df[, c(1, 2, 4)]
colnames(subset_attend)[1] <- "Previous years attended"
colnames(subset_attend)[2] <- "Count"
colnames(subset_attend)[3] <- "Percent"
knitr::kable(subset_attend)
# table showing stats instead of chart
subset_attend <- attend_count_df[, c('attendance', 'count_24', 'percent_round_24')]
colnames(subset_attend)[1] <- "Previous years attended"
colnames(subset_attend)[2] <- "Count"
colnames(subset_attend)[3] <- "Percent"
knitr::kable(subset_attend)
